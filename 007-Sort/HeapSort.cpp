#include "swap.h"

// 构建大堆顶
void max_heapify(int arr[],int start,int end){
    // 根结点
    int dad = start;
    // 左子树结点，这里选择左子树是因为左子树只要加1就可以变为右子树
    int son = dad * 2 +1;
    while(son <= end){
        // 如果右子树比左子树更大，移动指针到右子树
        if(son + 1 < end && arr[son] < arr[son+1]){
            son++;
        }
        // 如果子结点比根结点大，则交换，保证根结点为区间最大值，然后依次构建自己子结点的子树
        if(arr[dad] > arr[son]){
            break;
        } else {
            sort_swap(arr,dad,son);
            dad = son;
            son = dad * 2 +1;
        }
    }
}

void heap(int arr[],int len){
    /**
     * 
     * 构建一个最大堆，最大堆定义：
     *      堆是一棵具备完全二叉树的树型数据结构，并且其左右结点必定小于根结点
     * {1,9,4,2,8,7}
     * 
     *         9
     *       /   \
     *      8     7
     *     / \   /
     *    4   2  1
     * 
     *  {9,8,7,4,2,1}
     * 
     * 因为数组以0开始，相当于树从0开始编号，
     * 即根结点的左子树下标等于【根结点*2+1】，
     * left = root*2+1;
     * 根结点右子树下标为【根结点*2+2】
     * right = root*2+2;
     * 
     * 构造最大堆可以通过从最后一个根结点(R_last)开始构建，根据根结点定义，
     * 其出度>0,即至少一个左结点，也就是说最后一个结点n-1=max{R_left,R_right}
     * 
     * 分类讨论：
     *     1. （n-1）最后一个节点为右结点情况
     *        当n-1为右结点情况，那么此时整棵树的所有结点的出度要么为0，要么为2。
     *     这里设n_0为出度为0的结点，n_2为出度为2的结点。根据n_0=n_2+1，2*n_2+1就
     *     为整棵树的大小n-1,此时n-1也是这个root右结点的下标位置，求它的根的下标位置，
     *     因为2*n_2+1必定为奇数，所以n此时必然为偶数，根据n-1=root*2+2，求
     *     得root=(n-3)/2，由于计算机运算性质，除法会自动忽略余数，由于n为偶数，
     *     可以被整除，3与2相处会出现余数1，这个余数1会被自动忽略，所以表达式同等于root=n/2-1.
     * 
     *     2. (n-1)最后一个节点为左结点情况
     *        当n-1为左结点时，根据上一步推理，n必定为偶数，n-1必然为奇数，根据
     *     n-1=root*2+1，求解出root=n/2-1,由于n为偶数，所以正常运算。
     * 
     *     根据上两步讨论，结果为，最后一个根结点下标总是会收敛于
     *              i=n/2-1
     *     其中i就是最后一个根结点下标位置。
     * 
     * 
     * 我们记录最后一个根结点为R_last,再可知R_first为第一个根结点，也就是为0。可
     * 得R_last -> R_first 方向遍历，即最大堆的目标就是从R_last往R_first遍历
     * 构建一棵树
     */
    for(int i = len/2-1;i >= 0; i--){
        max_heapify(arr,i,len -1);
    }
    /**
     * 
     * 依次将顶部根结点与最后一个叶子结点交换位置，此时根部的最大值便
     * 为移动到数组最后一位，再次在【0，n-1】除执行一次构建最大堆
     * 
     * 最后最大的元素会依次填入到数组尾部，也就是最小的值会慢慢浮现到
     * 树首部，这点非常类似于选择排序（从数组依次选择最小值填入数组前部）。
     * 只不过选择排序每次的查找min是线性的时间复杂度O（n）
     * 
     * 而堆排序由于树特性，查找效率等同于树的高度，二叉树的高度公式为logN,
     * 即查找效率是O(logN)
     * 
     *
     */
    for(int i = len -1; i> 0; i--){
        sort_swap(arr,0,i);
        max_heapify(arr,0,i-1);
    }
}